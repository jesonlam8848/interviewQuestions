# 计算机网络

### 1. GET和POST的请求的区别

Post 和 Get 是 HTTP 请求的两种方法，其区别如下：

- **应用场景：** 一般 Get 请求用于对服务器资源不会产生影响的场景，比如说请求一个网页的资源。而 Post 一般用于对服务器资源会产生影响的情景，比如注册用户这一类的操作。
- **是否缓存：** 因为两者应用场景不同，浏览器一般会对 Get 请求缓存，但很少对 Post 请求缓存。
- **发送的报文格式：** Get 请求的报文中实体部分为空，Post 请求的报文中实体部分一般为向服务器发送的数据。
- **安全性：** Get 请求可以将请求的参数放入 url 中向服务器发送，这样的做法相对于 Post 请求来说是不太安全的，因为请求的 url 会被保留在历史记录中。
- **请求长度：** 浏览器由于对 url 长度的限制，所以会影响 get 请求发送数据时的长度。这个限制是浏览器规定的，并不是 RFC 规定的。

### 2. HTTP和HTTPS协议的区别

HTTP和HTTPS协议的主要区别如下：

- HTTPS协议需要CA证书，费用较高；而HTTP协议不需要；
- HTTP协议是超文本传输协议( 从服务器传输超文本到本地了浏览器 )，信息是明文传输的，HTTPS则是具有安全性的SSL加密传输协议；
- HTTP协议默认端口为80, HTTPS则为443

### 3.HTTP状态码

状态码的类别：

| **类别** | **原因**                        | **描述**                   |
| -------- | ------------------------------- | -------------------------- |
| 1xx      | Informational(信息性状态码)     | 接受的请求正在处理         |
| 2xx      | Success(成功状态码)             | 请求正常处理完毕           |
| 3xx      | Redirection(重定向状态码)       | 需要进行附加操作一完成请求 |
| 4xx      | Client Error (客户端错误状态码) | 服务器无法处理请求         |
| 5xx      | Server Error(服务器错误状态码)  | 服务器处理请求出错         |

#### 1. 2XX (Success 成功状态码)

状态码2XX表示请求被正常处理了。

##### （1）200 OK

200 OK表示客户端发来的请求被服务器端正常处理了。

##### （2）204 No Content

该状态码表示客户端发送的请求已经在服务器端正常处理了，但是没有返回的内容，响应报文中不包含实体的主体部分。一般在只需要从客户端往服务器端发送信息，而服务器端不需要往客户端发送内容时使用。

#### 2. 3XX (Redirection 重定向状态码)

3XX 响应结果表明浏览器需要执行某些特殊的处理以正确处理请求。

##### （1）301 Moved Permanently

**永久重定向。** 该状态码表示请求的资源已经被分配了新的 URI，以后应使用资源指定的 URI。新的 URI 会在 HTTP 响应头中的 Location 首部字段指定。若用户已经把原来的URI保存为书签，此时会按照 Location 中新的URI重新保存该书签。同时，搜索引擎在抓取新内容的同时也将旧的网址替换为重定向之后的网址。

**使用场景：**

- 当我们想换个域名，旧的域名不再使用时，用户访问旧域名时用301就重定向到新的域名。其实也是告诉搜索引擎收录的域名需要对新的域名进行收录。
- 在搜索引擎的搜索结果中出现了不带www的域名，而带www的域名却没有收录，这个时候可以用301重定向来告诉搜索引擎我们目标的域名是哪一个。

##### （2）302 Found

**临时重定向。** 该状态码表示请求的资源被分配到了新的 URI，希望用户（本次）能使用新的 URI 访问资源。和 301 Moved Permanently 状态码相似，但是 302 代表的资源不是被永久重定向，只是临时性质的。也就是说已移动的资源对应的 URI 将来还有可能发生改变。若用户把 URI 保存成书签，但不会像 301 状态码出现时那样去更新书签，而是仍旧保留返回 302 状态码的页面对应的 URI。同时，搜索引擎会抓取新的内容而保留旧的网址。因为服务器返回302代码，搜索引擎认为新的网址只是暂时的。

**使用场景：**

- 当我们在做活动时，登录到首页自动重定向，进入活动页面。
- 未登陆的用户访问用户中心重定向到登录页面。
- 访问404页面重新定向到首页。

##### （3）304 Not Modified

**浏览器缓存相关。** 该状态码表示客户端发送附带条件的请求时，服务器端允许请求访问资源，但未满足条件的情况。304 状态码返回时，不包含任何响应的主体部分。304 虽然被划分在 3XX 类别中，但是和重定向没有关系。

带条件的请求（Http 条件请求）：使用 Get方法 请求，请求报文中包含（`if-match`、`if-none-match`、`if-modified-since`、`if-unmodified-since`、`if-range`）中任意首部。

状态码304并不是一种错误，而是告诉客户端有缓存，直接使用缓存中的数据。返回页面的只有头部信息，是没有内容部分的，这样在一定程度上提高了网页的性能。

#### 3. 4XX (Client Error 客户端错误状态码)

4XX 的响应结果表明客户端是发生错误的原因所在。

##### （1）400 Bad Request

该状态码表示请求报文中存在语法错误。当错误发生时，需修改请求的内容后再次发送请求。另外，浏览器会像 200 OK 一样对待该状态码。

##### （2）403 Forbidden

该状态码表明请求资源的访问被服务器拒绝了，服务器端没有必要给出详细理由，但是可以在响应报文实体的主体中进行说明。进入该状态后，不能再继续进行验证。该访问是永久禁止的，并且与应用逻辑密切相关。

##### （3）404 Not Found

该状态码表明服务器上无法找到请求的资源。除此之外，也可以在服务器端拒绝请求且不想说明理由时使用。 

##### （4）405 Method Not Allowed

该状态码表示客户端请求的方法虽然能被服务器识别，但是服务器禁止使用该方法。GET 和 HEAD 方法，服务器应该总是允许客户端进行访问。客户端可以通过 OPTIONS 方法（预检）来查看服务器允许的访问方法, 如下

```javascript
Access-Control-Allow-Methods: GET,HEAD,PUT,PATCH,POST,DELETE
复制代码
```

#### 4. 5XX (Server Error 服务器错误状态码)

5XX 的响应结果表明服务器本身发生错误.

##### （1）500 Internal Server Error

该状态码表明服务器端在执行请求时发生了错误。也有可能是 Web 应用存在的 bug 或某些临时的故障。

##### （2）503 Service Unavailable

该状态码表明服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。如果事先得知解除以上状况需要的时间，最好写入 RetryAfter 首部字段再返回给客户端。

**使用场景：**

- 服务器停机维护时，主动用503响应请求；
- nginx 设置限速，超过限速，会返回503。

#### 5. 总结

**（1）2XX 成功**

- 200 OK，成功
- 204 No content，返回内容为空

**（2）3XX 重定向**

- 301 moved permanently，永久性重定向
- 302 found，临时性重定向
- 304 not modified，有缓存

**（3）4XX 客户端错误**

- 400 bad request，请求报文语法错误
- 403 forbidden，被服务器拒绝
- 404 not found，服务器上没有找到请求的资源
- 405 请求的方法是服务器中禁用的

**（4）5XX 服务器错误**

- 500 internal sever error，服务器端在执行请求时发生了错误
- 503 service unavailable，服务器处于超负载或正在停机维护

### 4.TCP三挥四握

#### TCP三次握手

1. 第一次握手：`建立连接时，客户端发送syn包（syn=j）到服务器，并进入SYN_SENT状态，等待服务器确认`；SYN：同步序列编号（Synchronize Sequence Numbers）。
2. 第二次握手：`服务器收到syn包并确认客户的SYN`（ack=j+1），`同时也发送一个自己的SYN包`（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；
3. 第三次握手：`客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1）`，此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。

#### TCP四次挥手

- 第一次挥手： 客户端会发送一个 FIN 包，此时客户端处于终止等待一状态(FIN_WAIT1)。

- 第二次挥手：服务端收到之后，会发送 ACK 包，此时服务端处于关闭等待状态(CLOSE_WAIT) , 客户端进入终止等待二状态(FIN_WAIT2)。服务端此时还可以发送未发送的数据给客户端

- 第三次挥手：服务端如果发送完数据之后，会发 FIN 包，此时服务端处于最后确认状态(LAST_ACK)。

- 第四次挥手：客户端收到之后，发送一个 ACK包，此时客户端处于超时等待状态 (TIME_WAIT) 。经过超时时间后关闭连接，服务端收到 ACK 报文之后立即关闭连接。

### 5.从输入URL到页面加载的全过程

1. 首先在浏览器中输入URL

2. 查找缓存

3. DNS域名解析

4. TCP三次握手

5. 发起HTTP请求

6. 服务器响应请求并返回结果

7. 通过TCP四次挥手关闭连接

####   8. 浏览器渲染：

> 客户端（浏览器）解析HTML内容并渲染出来

   - 构建DOM树：词法分析然后解析成DOM树（dom tree），是由dom元素及属性节点组成，树的根是document对象
   - 构建CSS规则树：生成CSS规则树（CSS Rule Tree）
   - 构建render树：Web浏览器将DOM和CSSOM结合，并构建出渲染树（render tree）
   - 布局（Layout）：计算出每个节点在屏幕中的位置
   - 绘制（Painting）：即遍历render树，并使用UI后端层绘制每个节点。

   ![浏览器渲染流程图](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a90660027f0d4c559732519bad4c6323~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)

9. JS引擎解析

### 6.Axios
 特点:

- Axios 是一个基于 promise 的 HTTP 库，支持promise所有的API
- 有请求/响应拦截器
- 它可以转换请求数据和响应数据，并对响应回来的内容自动转换成 JSON类型的数据
- 安全性更高
- 支持浏览器和node.js

常用方法:

1. axios.get(url[, config]) //get请求用于列表和信息查询
2. axios.delete(url[, config]) //删除
3. axios.post(url[, data[, config]]) //post请求用于信息的添加
4. axios.put(url[, data[, config]]) //更新操作

相关配置属性:

- `baseURL`将自动加在`url`前面，除非`url`是一个绝对URL。它可以通过设置一个`baseURL`便于为axios实例的方法传递相对URL

- `url`是用于请求的服务器URL

- `method`是创建请求时使用的方法,默认是get

- `headers`是即将被发送的自定义请求头

- `params`是即将与请求一起发送的URL参数
